//
//  {{fileName}}
//  {{projectName}}
//
//  Created by {{author}} on {{date}}.
//  {{copyright}}
//

import RxCocoa
import RxDataSources
import RxSwift

final class {{Name}}ViewModel: ViewModelType {
    private let selection: BehaviorRelay<SubscriptionFrequency>
    private let disposeBag = DisposeBag()

    // MARK: Private properties
    private let apiService: AppServicing
    private let inAppPurchaseManager: InAppPurchaseManaging
    private let keychainManager: KeychainManaging

    // MARK: Lifecycle

    deinit {
        print("Deinit \(self)")
    }

    init(apiService: AppServicing, inAppPurchaseManager: InAppPurchaseManaging, keychainManager: KeychainManaging) {
        self.apiService = apiService
        self.inAppPurchaseManager = inAppPurchaseManager
        self.keychainManager = keychainManager

        var currentSelection: SubscriptionFrequency
        if keychainManager.activeSubscription == nil || keychainManager.activeSubscription == false {
            currentSelection = .nothing
        } else {
            currentSelection = keychainManager.subscriptionFrequency
        }

        selection = BehaviorRelay<SubscriptionFrequency>(value: currentSelection)
    }
}

// MARK: - Input / output transformation

extension {{Name}}ViewModel {
    struct Input {
        let viewWillAppear: Observable<Void>
        let annuallySubscriptionToggleSelection: Observable<Void>
        let monthlySubscriptionToggleSelection: Observable<Void>
        let actionButtonTapped: Observable<Void>
    }

    struct Output {
        let selection: Driver<SubscriptionFrequency>
        let annuallySubscriptionPurchased: Driver<Void>
        let monthlySubscriptionPurchased: Driver<Void>
        let purchasesRestored: Driver<Void>
        let errors: Driver<Error>
        let paymentMethod: Driver<SubscriptionPaymentMethod>
    }

    func transform(input: {{Name}}ViewModel.Input) -> {{Name}}ViewModel.Output {
        input.annuallySubscriptionToggleSelection
            .withUnretained(self)
            .subscribeNext { viewModel, _ in
                viewModel.selection.accept((viewModel.selection.value == .year) ? .nothing : .year)
            }
            .disposed(by: disposeBag)

        input.monthlySubscriptionToggleSelection
            .withUnretained(self)
            .subscribeNext { viewModel, _ in
                viewModel.selection.accept((viewModel.selection.value == .month) ? .nothing : .month)
            }
            .disposed(by: disposeBag)

        let annuallySubscriptionPurchased = input.actionButtonTapped
            .withUnretained(self)
            .filter { viewModel, _ in
                viewModel.selection.value == .year
            }
            .withUnretained(self)
            .map { viewModel, _ in
                viewModel.inAppPurchaseManager.purchase(product: .annuallySubscription)
            }
            .flatMap { $0.materialize() }
            .share()

        let monthlySubscriptionPurchased = input.actionButtonTapped
            .withUnretained(self)
            .filter { viewModel, _ in
                viewModel.selection.value == .month
            }
            .withUnretained(self)
            .map { viewModel, _ in
                viewModel.inAppPurchaseManager.purchase(product: .monthlySubscription)
            }
            .flatMap { $0.materialize() }
            .share()

        let purchasesRestored = input.actionButtonTapped
            .withUnretained(self)
            .filter { viewModel, _ in
                viewModel.selection.value == .nothing
            }
            .withUnretained(self)
            .map { viewModel, _ in
                viewModel.inAppPurchaseManager.getActiveSubscription()
            }
            .flatMap { $0.materialize() }
            .share()

        let errors = Observable.merge(
            annuallySubscriptionPurchased.errors(),
            monthlySubscriptionPurchased.errors(),
            purchasesRestored.errors()
        )

        return Output(
            selection: selection.asDriverOnErrorJustComplete(),
            annuallySubscriptionPurchased: annuallySubscriptionPurchased.elements().asDriverLogError(),
            monthlySubscriptionPurchased: monthlySubscriptionPurchased.elements().asDriverLogError(),
            purchasesRestored: purchasesRestored.elements().mapToVoid().asDriverLogError(),
            errors: errors.asDriverOnErrorJustComplete(),
            paymentMethod: Driver.just(keychainManager.subscriptionPaymentMethod)
        )
    }
}
